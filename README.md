# Distributed Game Architecture

This repository contains the source code to a distributed gaming service, which uses a single server application to render and stream the perspective of multiple connected client applications in a shared game scene.

The applications are written using C++ with OpenGL, and structured into projects through Premake5.

![A picture taken of the server application running on a desktop application, with two simultaneously connected client applications (each running on their own laptop)][deployed_system]



## Table of Contents

1. [Table of Contents](#table-of-contents)
2. [Installation and Compliation](#installation-and-compilation)
    2.1 [Prerequisites](#prerequisites)
    2.2 [Installation](#installation)
    2.3 [Compliation](#compilation)
3. [Execution and Deployment](#execution-and-deployment)
4. [Test Scenarios](#test-scenarios)
5. [Third-Party Software Libraries](#third-party-software-libraries)


## Installation and Compilation

### Prerequisites

1. This system currently only supports the Windows operating system.
2. The [Premake5][premake5_homepage] command-line utility is used to generate the required IDE project files to describe the files within this project as distinct, inter-linked applications. You must install this command-line utility (following the guide [here][premake5_getting_started]) to follow the provided instructions when building the source code through an IDE.
3. The software system is written using C++20, meaning you must have a C++ compiler installed capable of compiling C++20 source code. Version 14.34.31938 of the MSVC compiler was used during development and is known to work.
4. You must have an already downloaded IDE, which is supported by Premake5, to follow the provided compilation instructions. To find a list of supported IDEs, or to check whether your IDE is supported, please follow the list [here][premake5_generate_ide_files]. Visual Studio 2022 was used during development and is known to work.

### Installation

To install this project, you must clone or download a copy of your chosen commit or the repository.
No further steps are required to install the code-base, provided the prerequisites are met for this project.

### Compilation

With a local copy of the repository files downloaded, you can follow the below steps to first generate the project files required for an IDE of your choosing to understand the source files, and then use your IDE to compile the project:

1. Open a command-line prompt in your local directory containing this `README.md` file.
2. Enter the Premake5 command used to generate the IDE project files for your chosen, installed IDE. These commands can be found 
For example, to generate the project files for the Visual Studio 2022 IDE, you may enter the command: \
`premake5 vs2022`.
3. Wait for the Premake5 command to successfully generate all necessary project files (please check the Premake5 documentation if any issues have occurred).
4. Open your chosen IDE and open the project files generated by Premake5.
5. You should now be able to see three software systems in your IDE, two executable software applications `Client` and `Server`, as well as a statically-linked library `Middleware`.
6. Use the usual process of your chosen IDE to build the three systems. For example, in Visual Studio 2022, this may be by using the menu option `Build > Build Solution`.
7. Wait for your IDE to compile and link the applications and libraries.
8. The system should now be successfully compiled.

## Execution and Deployment

You may execute the client and server applications through your chosen IDE by following the compilation steps and then running the code. For example, in Visual Studio 2022, this can be done by pressing the `Start` button after selecting your chosen configuration (`Release` is recommended unless you require additional debugging features).

However, to run the applications outside of an IDE:

1. First follow the compilation instructions provided above.
2. Find the generated executable files `Client.exe` and `Server.exe` in the created `bin` folder (under a subdirectory for the build configuration used - e.g. `Release-windows-x86_64/Client/` or `Release-windows-x86_64/Server/`, etc).
3. Copy the `Client.exe` and `Server.exe` files to the location you wish to store them.
4. Find the directory containing all assets (`assets/`) for the Client under the `Client/` directory, and copy it to the same location as your `Client.exe` executable.
5. Find the directory containing all assets (`assets/`) for the Server under the `Server/` directory, and copy it to the same location as your `Server.exe` executable.
6. To start the server, open a command-line prompt in the same location as the `Server.exe` file, and enter the command: \
`Server.exe [optional_integer_port_number (8080 is default)] [optional_maximum_lifetime_in_milliseconds (default setting is to run indefinitely, set to 0 for infinite life)] [optional_path_to_directory_for_analytics_files]`
7. To start the client, open a command-line prompt in the same location as the `Client.exe` file, and enter the command: \
`Client.exe [optional_server_ip_address (127.0.0.1 is default)] [optional_server_port (8080 is default)]  [optional_maximum_lifetime_in_milliseconds (default setting is to run indefinitely, set to 0 for infinite life)] [optional_integer_client_id (0 is default)] [optional_path_to_directory_for_analytics_files]`

A screenshot can be seen below of multiple instances of the client application running on the same computer as an instance of the server application through this method.

![An screenshot of a running test scenario, with one server application streaming frames of gameplay to seven simultaneously connected client applications on the same desktop][test_scenario]



## Test Scenarios

For testing purposes, it was necessary to spawn multiple instances of the client application at once on the same desktop as an instance of the server application.

As such, a Python script was written (`scripts/test.py`) that would first spawn a server application and one client application, wait for them to halt, and then spawn a new server application and two client applications, wait for them to halt, and so on, until thirty client applications had been connected simulaneously. \
The analytics for each number of simultaneous connections would be output to a created subdirectory specified.

When running this script, it is necessary to change three variables for your local setup: 
`SERVER_APPLICATION_PATH`, `CLIENT_APPLICATION_PATH` and `BASE_RESULTS_FOLDER_PATH`, which can be found at the top of the script file. 

- `SERVER_APPLICATION_PATH` is a string that provides the filepath of the `Server.exe` executable that can be created by following the Execution and Deployment instructions. The `Server.exe` file must be in the same location as the `Server/assets/` folder discussed in the Execution and Deployment instructions.
- `CLIENT_APPLICATION_PATH` is a string that provides the filepath of the `Client.exe` executable that can be created by following the Execution and Deployment instructions. The `Client.exe` file must be in the same location as the `Client/assets/` folder discussed in the Execution and Deployment instructions. 
- `BASE_RESULTS_FOLDER_PATH` is a directory path (which must end with a trailing forward slash), that tells the script where to store all the analytics files generated. The analytics for each number of connected clients will be stored in it's own folder within the directory specified (e.g. `1 Players`, `2 Players`, etc)

To execute the script, once configured for your environment:

1. Open a command-line prompt in the same directory as the script file.
2. Enter the python command to run the script file: \
`python test.py`
3. Wait for the test to complete.

A video of the output you may expect from the test can be found at `assets/demo.mp4`, although the applications have been instructed not to halt, and only one test scenario involving seven client applications is being shown.



## Third-Party Software Libraries

To create this system, several external software libraries have been used. In no particular order, these libraries are:

### GLEW (version 2.1.0)

GLEW is a software library that exposes OpenGL rendering API functionality through a C++ source code interface. Version 2.1.0 of the library can be found [here][glew_2_1_0], available under the Modified BSD License, the Mesa 3-D License (MIT) and the Khronos License (MIT), which can be found within the linked GLEW homepage or through the included `libs/GLEW2.1.0/LICENSE.md` file.

Specifically within this project, the GLEW software library is used to interact with and use modern features of the OpenGL rendering API.

### GLFW (version 3.3.8)

GLFW is a software library that provides cross-platform window creation and management features, as well as providing input detection and basic visual output support (when combined with the GLEW software library). Version 3.3.8 of the library can be found [here][glfw_3_3_8], available under the zlib/libpng license, which can be found within the linked GLFW homepage or through the included `libs/GLFW3.3.8/LICENSE.md` file.

Specifically within this project, GLFW is used to create an application window for the client application capable of displaying the frames of gameplay and detecting any user inputs. Furthermore, it is used to create an application window for the server application capable of displaying the frames of gameplay generated for each connected player. 

### GLM (version 0.9.8.8)

GLM is a software library that implements basic mathematic functions for 3D C++ applications. Version 0.9.9.8 of the library can be found [here][glm_0_9_9_8], available under The Happy Bunny License or MIT License, which can be found within the source files available for download at the provided link, or through the included `libs/GLM0.9.9.8/copying.txt` file.

Specifically within this project, GLM is used to construct matrices and vectors as well as perform matrix and vector operations.

### ZLib (version 1.2.13)

ZLib is software library that implements the DEFLATE compression algorithm for C++ programs. Version 1.2.13 of the library can be found [here][zlib_1_2_13], available under the ZLib license, which can be found at the linked homepage or within the included `libs/ZLIB1.2.13/LICENSE.md` file.

Specifically within this project, the ZLib library is used in conjunction with the Boost Iostreams software library to compress frames of gameplay before transmission and decompress them once received.

### Boost (version 1.82.0)

Boost is a set of software libraries that implement general functionality for C++ software projects. Version 1.82.0 of the library can be found [here][boost_1_82_0], available under the Boost software license, which can be found through the linked Boost homepage, or within the included `libs/BOOST1.82.0/LICENSE.md` file.

Specifically within this project, the Boost Iostreams library is used to provide a simpler C++ interface for the ZLib compression library. 




<!-- Local assets -->

[test_scenario]: assets/test_scenario.jpg "One server application streaming to seven simultaneously connected client applications running on the same desktop"

[deployed_system]: assets/deployed_system.jpg "One server application streaming to two simultaneously connected client applicatiosn, with each application running on a different computer connected via an internet connection"


<!-- Third-party software libraries -->

[glew_2_1_0]: https://glew.sourceforge.net/ "GLEW Downloads and Documentation"
[glfw_3_3_8]: https://www.glfw.org/ "GLFW Downloads and Documentation"
[glm_0_9_9_8]: https://github.com/g-truc/glm/releases/tag/0.9.9.8 "GLM Downloads"
[zlib_1_2_13]: https://www.zlib.net/ "ZLib 1.2.13 Downloads and Documentation"
[boost_1_82_0]: https://www.boost.org/users/history/version_1_82_0.html "Boost 1.82.0 Downloads and Documentation"


<!-- External links -->

[premake5_homepage]: https://premake.github.io/ "Premake5 Homepage"
[premake5_getting_started]: https://premake.github.io/docs/ "Premake5 Getting Started"
[premake5_generate_ide_files]: https://premake.github.io/docs/Using-Premake "Premake5 Generate Project Files For Various IDEs"